package gregtech.common.tileentities.machines.basic;import gregtech.api.enums.ItemList;import gregtech.api.enums.Textures;import gregtech.api.gui.GT_Container_1by1;import gregtech.api.gui.GT_GUIContainer_1by1;import gregtech.api.interfaces.ITexture;import gregtech.api.interfaces.metatileentity.IDataConnected;import gregtech.api.interfaces.metatileentity.IDataDevice;import gregtech.api.interfaces.metatileentity.IMetaTileEntity;import gregtech.api.interfaces.metatileentity.IMetaTileEntityDataCable;import gregtech.api.interfaces.tileentity.IGregTechTileEntity;import gregtech.api.items.GT_MetaGenerated_Tool;import gregtech.api.metatileentity.BaseTileEntity;import gregtech.api.metatileentity.MetaTileEntity;import gregtech.api.metatileentity.implementations.GT_MetaPipeEntity_DataCable;import gregtech.api.metatileentity.implementations.GT_MetaTileEntity_BasicMachine;import gregtech.api.objects.GT_RenderedTexture;import gregtech.api.util.GT_Utility;import gregtech.common.tileentities.machines.multi.GT_MetaTileEntity_ComputerBase;import gregtech.common.tileentities.machines.multi.GT_MetaTileEntity_DataWorkerBase;import gregtech.common.tileentities.machines.multi.GT_MetaTileEntity_LargeResearchStationBase;import net.minecraft.entity.player.EntityPlayer;import net.minecraft.entity.player.InventoryPlayer;import net.minecraft.item.ItemStack;import net.minecraft.nbt.NBTTagCompound;import net.minecraft.tileentity.TileEntity;import net.minecraftforge.fluids.FluidStack;import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;public class GT_MetaTileEntity_Commutator extends GT_MetaTileEntity_BasicMachine implements IDataConnected {    public boolean mUpdateNeeded = true;    public ArrayList<GT_MetaTileEntity_ComputerBase> mComputers = new ArrayList<>();    public ArrayList<GT_MetaTileEntity_DataWorkerBase> mDevices = new ArrayList<>();    public ArrayList<GT_MetaTileEntity_LargeResearchStationBase> mStations = new ArrayList<>();    public ArrayList<computationOrder> mProcessingOrders = new ArrayList<>();    int mDefaultWorkCycleTime = 20;    int mLastWorkCycle = 0;    byte mPCsSide = 2;    byte mDevicesSide = 3;    public GT_MetaTileEntity_Commutator(int aID, String aName, String aNameRegional, int aTier) {        super(aID, aName, aNameRegional, aTier, 1, "Heats tools for hardening", 1, 1, "E_Oven.png", "", new ITexture[]{new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_SIDE_ACTIVE")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_SIDE")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_FRONT_ACTIVE")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_FRONT")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_TOP_ACTIVE")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_TOP")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_BOTTOM_ACTIVE")), new GT_RenderedTexture(new Textures.BlockIcons.CustomIcon("basicmachines/ELECTRIC_OVEN/OVERLAY_BOTTOM"))});    }    public GT_MetaTileEntity_Commutator(String aName, int aTier, String aDescription, ITexture[][][] aTextures, String aGUIName, String aNEIName) {        super(aName, aTier, 1, aDescription, aTextures, 1, 1, aGUIName, aNEIName);    }    public GT_MetaTileEntity_Commutator(String aName, int aTier, String[] aDescription, ITexture[][][] aTextures, String aGUIName, String aNEIName) {        super(aName, aTier, 1, aDescription, aTextures, 1, 1, aGUIName, aNEIName);    }    public MetaTileEntity newMetaEntity(IGregTechTileEntity aTileEntity) {        return new GT_MetaTileEntity_Commutator(this.mName, this.mTier, this.mDescriptionArray, this.mTextures, this.mGUIName, this.mNEIName);    }    public boolean allowPutStack(IGregTechTileEntity aBaseMetaTileEntity, int aIndex, byte aSide, ItemStack aStack) {        return false;    }    public boolean isFluidInputAllowed(FluidStack aFluid) {        return false;    }    public class computationOrder{        public int mTime;        public int mComputation;        public GT_MetaTileEntity_LargeResearchStationBase mStation;        public ArrayList<GT_MetaTileEntity_ComputerBase> mComputers = new ArrayList<>();        public ArrayList<GT_MetaTileEntity_DataWorkerBase> mDevices = new ArrayList<>();        public computationOrder(int aTime,int aComputation, GT_MetaTileEntity_LargeResearchStationBase aStation){            mTime = aTime;            mComputation = aComputation;            mStation = aStation;        }    }    @Override    public int checkRecipe() {        if(mStations.size()==0||mComputers.size()==0)            mUpdateNeeded=true;        if(mUpdateNeeded){            mComputers.clear();            mDevices.clear();            mStations.clear();            updateSide(getPCsSide());            updateSide(getDevicesSide());            mUpdateNeeded = false;        }        int nextWorkCycle = mDefaultWorkCycleTime;        Iterator<computationOrder> iterator = mProcessingOrders.iterator();        while (iterator.hasNext()) {            computationOrder aOreder =iterator.next();            aOreder.mTime -= mLastWorkCycle;            if (aOreder.mTime <= 0) {                removeWrongOrder(aOreder,iterator);            } else {                nextWorkCycle = aOreder.mTime>mDefaultWorkCycleTime? mDefaultWorkCycleTime: (aOreder.mTime);                boolean remove = false;                if (!aOreder.mStation.getWorkingStatus())                    remove = true;                for (GT_MetaTileEntity_DataWorkerBase aWorker : aOreder.mComputers) {                    if (!aWorker.getWorkingStatus())                        remove = true;                }                for (GT_MetaTileEntity_DataWorkerBase aWorker : aOreder.mDevices) {                    if (!aWorker.getWorkingStatus())                        remove = true;                }                if (remove)                    removeWrongOrder(aOreder,iterator);            }        }        ArrayList<Object[]> mComputationRequests = new ArrayList<>();        for(GT_MetaTileEntity_LargeResearchStationBase aStation : mStations){            if(aStation.getRequest()!=null)                if(aStation.getRequest()[0]!=null)                    mComputationRequests.add(aStation.getRequest());        }        for(Object[] aRequest : mComputationRequests) {            computationOrder tOrder =new computationOrder((int)aRequest[0],(int)aRequest[1],(GT_MetaTileEntity_LargeResearchStationBase)aRequest[2]);            int tNeededComputations = (int)aRequest[1];            int tTotalCalcPower = 0;            for(GT_MetaTileEntity_ComputerBase tComputer: mComputers){                if(!tComputer.getWorkingStatus())                    tTotalCalcPower += tComputer.getCalculationPower();            }            if(tTotalCalcPower<tNeededComputations)                continue;            for (GT_MetaTileEntity_ComputerBase aComputer : mComputers) {                if(tNeededComputations<0)                    continue;                if(!aComputer.getWorkingStatus())                {                    tNeededComputations -= aComputer.getCalculationPower();                    tOrder.mComputers.add(aComputer);                }                ;            }            //add devices to order            System.out.println("starting "+tNeededComputations+" "+tTotalCalcPower);            if(tNeededComputations<=0)                startNewOrderProcessing(tOrder);        }        mLastWorkCycle = mMaxProgresstime = nextWorkCycle;        return 2;    }    public byte getPCsSide(){        return mPCsSide;    }    public byte getDevicesSide(){        return mDevicesSide;    }    public boolean addDevice(IDataDevice aDevice){        if(aDevice instanceof  GT_MetaTileEntity_ComputerBase && !mComputers.contains(aDevice))            mComputers.add((GT_MetaTileEntity_ComputerBase)aDevice);        else if(aDevice instanceof GT_MetaTileEntity_LargeResearchStationBase&& !mStations.contains(aDevice)){            ((GT_MetaTileEntity_LargeResearchStationBase) aDevice).aCommutator = this;            mStations.add((GT_MetaTileEntity_LargeResearchStationBase)aDevice);        }        else if(aDevice instanceof GT_MetaTileEntity_DataWorkerBase && !mDevices.contains(aDevice))            mDevices.add((GT_MetaTileEntity_DataWorkerBase)aDevice);        else            return false;        return true;    }    public boolean updateSide(byte aSide){        final IGregTechTileEntity baseMetaTile = getBaseMetaTileEntity();        IGregTechTileEntity tTileEntity = (IGregTechTileEntity)(baseMetaTile.getTileEntityAtSide(aSide)instanceof IGregTechTileEntity?baseMetaTile.getTileEntityAtSide(aSide):null);        if(tTileEntity!=null&&tTileEntity.getMetaTileEntity() instanceof GT_MetaPipeEntity_DataCable){            ((GT_MetaPipeEntity_DataCable)tTileEntity.getMetaTileEntity()).transferRef(GT_Utility.getOppositeSide(aSide),this,new HashSet<TileEntity>());            return true;        }        return false;    }    private void removeWrongOrder(computationOrder aOrder, Iterator<computationOrder> iter){        iter.remove();        if(aOrder.mTime<=1)            return;        aOrder.mStation.abortProcces();        for(GT_MetaTileEntity_DataWorkerBase aWorker:aOrder.mComputers){            aWorker.abortProcces();        }        for(GT_MetaTileEntity_DataWorkerBase aWorker:aOrder.mDevices){            aWorker.abortProcces();        }    }    private void startNewOrderProcessing(computationOrder aOrder){        mProcessingOrders.add(aOrder);        aOrder.mStation.startProcessing();        int calculations = aOrder.mComputation;        for(GT_MetaTileEntity_ComputerBase aWorker:aOrder.mComputers){            if(calculations<0)                continue;            if(calculations>aWorker.getCalculationPower())                aWorker.requestCalculations(new Object[]{aOrder.mTime,aWorker.getCalculationPower(),aOrder.mStation});            else                aWorker.requestCalculations(new Object[]{aOrder.mTime,calculations,aOrder.mStation});            calculations-=aWorker.getCalculationPower();            aWorker.startProcessing();        }        for(GT_MetaTileEntity_DataWorkerBase aWorker:aOrder.mDevices){            aWorker.startProcessing();        }    }    @Override    public void onScrewdriverRightClick(byte aSide, EntityPlayer aPlayer, float aX, float aY, float aZ) {        super.onScrewdriverRightClick(aSide, aPlayer, aX, aY, aZ);        if(aPlayer.isSneaking()){            mPCsSide = aSide;            GT_Utility.sendChatToPlayer(aPlayer,"Computers Side Is set");        }        else {            mDevicesSide = aSide;            GT_Utility.sendChatToPlayer(aPlayer,"Devices Side Is Set");        }        mUpdateNeeded = true;    }    @Override    public boolean onWrenchRightClick(byte aSide, byte aWrenchingSide, EntityPlayer aPlayer, float aX, float aY, float aZ) {        checkRecipe();            return false;    }    @Override    public String[] getInfoData() {        return new String[]{                "C"        };    }    @Override    public boolean transfersDataAt(byte aSide) {        return aSide!=getBaseMetaTileEntity().getFrontFacing();    }    @Override    public void saveNBTData(NBTTagCompound aNBT) {        aNBT.setByte("PCSide",mPCsSide);        aNBT.setByte("DSide",mDevicesSide);        super.saveNBTData(aNBT);    }    @Override    public void loadNBTData(NBTTagCompound aNBT) {        mPCsSide = aNBT.getByte("PCSide");        mDevicesSide = aNBT.getByte("DSide");        super.loadNBTData(aNBT);    }    public boolean saveData(ItemStack aStack){        for(GT_MetaTileEntity_ComputerBase aComputer:mComputers){            if(aComputer.getFreeSpace()>0){                aComputer.saveRecipeData(aStack.writeToNBT(new NBTTagCompound()));                return true;            }        }        return false;    }    @Override    public void endProcess() {        super.endProcess();        if(!getBaseMetaTileEntity().isAllowedToWork()) for(GT_MetaTileEntity_LargeResearchStationBase aStation:mStations)            aStation.abortProcces();    }}